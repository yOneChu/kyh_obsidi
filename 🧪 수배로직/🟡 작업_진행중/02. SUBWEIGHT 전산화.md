
---




### Check List
- [ ] 국내꺼 전산화 해야됨
- [ ] df




### 참고사항
- [[SUB-WEIGHT_계산식]]
- LUXEN-G는 CWT를 BG 1000, 폭180 or BG 1200, 폭 180을 쓴다.

민욱M이 설계할 거 애기해줄 예정


> 콘크리트CONCRETE < 주물FC < 철판SS400 순으로  고비중
> 5.2가 안들어가면 5.2보다 고비중써야 된다.
> 그동안은 A -> AB -> B -> BC -> C 순으로 했다.
> 근데 동기 생각으로는 알기로는 "콘크리트 A ,B >>>>넘사벽 FC >>>넘사벽 SS400" 이라서 AC넣어서 C가 많이 나오는것보다 BC넣어서 C가 그나마 적게 나오는게 쌀 것이다.

---

### JAVA PID로 하는 이유
```
<단가 정보 요청 사유>

: 김동민M님과 회의시 말씀드린 대로 최적의 SUBWEIGHT 조합에 대해서 기존에는 동일무게로 수량을 구할 수 있었으나,

30,40kg가 혼재됨에 따라 기존의 전산화 방식으로는 최적의 조합을 구현하기가 어려워 기능개발을 통하여 JAVA CODE로 구현하기로 함

이때 우선순위 선정시 “무게 최소화”나 “적재 공간 최대화”로는 최적의 구성이 불가하여 단가 DATA를 통하여 최적의 조합을 구현하고자 함
```

| 동기 요청사항

> SUVF 말고는 다해야 된다.
> NEX-G ,LUXEN-G, NEX, WB 는 지금 자재번호가 고정이 안되어서 아직 못하고.
> 22일가지 해야되는게 LUXEN-G, NEX-G 이다.
> 

```
서브웨이트 전산화해보실거죠?

서브웨이트 로직 크게 4개인데 각각 확인해보시고 어떻게 짜실지, 한번 시뮬해보세요. 

우선 PICK_B181B_LUXEN_G 루젠G 담당으로 드릴게요.

PICK_B181B_NEX  
PICK_B181B_SU  
PICK_B181B_LUXEN_G  
PICK_B181B_NEX_PLANB
```
---

| FUNCTION_CALSUBWEIGHT 사용방법
```

INPUT : 
	SUB_WT_1        1st 자재의 개당 무게
	SUB_H_1          1st 자재의 개당 두께
	SUB_P_1          1st 자재의 개당 가격
	SUB_WT_2     2nd 자재의 개당 무게
	SUB_H_2        2nd 자재의 개당 두께
	SUB_P_2          2nd  자재의 개당 가격
	SUB_NEED_WT   SUBWEIGHT 최소 필요 무게
	SUB_MAX_LOAD_H      SUBWEIGHT 최대 적재가능 높이

OUTPUT:
	SUB_BEST_Q1        1st 자재의 최적 갯수
	SUB_BEST_Q2       2nd 자재의 최적 갯수

1. KEY 값에 `FUNCTION_CALSUBWEIGHT` 에서 사용할 매개변수를 미리 선언.
2. 예시. KEY: SUB_WT_1

```



| SUB-WEIGHT 계산식
![[Pasted image 20251209112101.png]]

```
public VariantMap FUNCTION_CALSUBWEIGHT(Map elvEnt, List<Map> floorMasterList, Map partInfo)  
          throws Exception {

      VariantMap result = new VariantMap();

      // 입력값 읽기  
      String Xs  = StringUtil.NVL(elvEnt.get("SUB_WT_1"), "");  
      String As  = StringUtil.NVL(elvEnt.get("SUB_H_1"), "");  
      String P1s = StringUtil.NVL(elvEnt.get("SUB_P_1"), "");

      String Ys  = StringUtil.NVL(elvEnt.get("SUB_WT_2"), "");  
      String Bs  = StringUtil.NVL(elvEnt.get("SUB_H_2"), "");  
      String P2s = StringUtil.NVL(elvEnt.get("SUB_P_2"), "");

      String AA_s = StringUtil.NVL(elvEnt.get("SUB_NEED_WT"), "");  
      String BB_s = StringUtil.NVL(elvEnt.get("SUB_MAX_LOAD_H"), "");

      // ★ 숫자 체크 (정수만 허용)  
      if (!isInteger(Xs) || !isInteger(As) || !isInteger(P1s)  
              || !isInteger(Ys) || !isInteger(Bs) || !isInteger(P2s)  
              || !isInteger(AA_s) || !isInteger(BB_s)) {

          result.put("SUB_BEST_Q1", "9999");  
          result.put("SUB_BEST_Q2", "9999");  
          return result;  
      }

      // 파싱  
      int X  = Integer.parseInt(Xs);  
      int A  = Integer.parseInt(As);  
      int p1 = Integer.parseInt(P1s);

      int Y  = Integer.parseInt(Ys);  
      int B  = Integer.parseInt(Bs);  
      int p2 = Integer.parseInt(P2s);

      int AA = Integer.parseInt(AA_s);  // 최소 무게  
      int BB = Integer.parseInt(BB_s);  // 최대 두께

      int max = 200;

      boolean found = false;  
      int bestC = -1, bestD = -1;

      int bestCost = Integer.MAX_VALUE;  
      int bestDiff1 = Integer.MAX_VALUE;  // (sum1 - AA)  
      int bestDiff2 = Integer.MAX_VALUE;  // (BB - sum2)

      for (int C = 0; C <= max; C++) {  
          for (int D = 0; D <= max; D++) {

              int sum1 = X * C + Y * D;  
              int sum2 = A * C + B * D;

              if (sum1 < AA) continue;   // 무게 조건  
              if (sum2 > BB) continue;   // 두께 조건 (≤ BB 허용)

              int cost = p1 * C + p2 * D;

              int diff1 = sum1 - AA; // 최소 초과량  
              int diff2 = BB - sum2; // 최대한 근접하도록

              if (cost < bestCost  
                      || (cost == bestCost && (diff1 < bestDiff1  
                      || (diff1 == bestDiff1 && diff2 < bestDiff2)))) {

                  bestCost = cost;  
                  bestDiff1 = diff1;  
                  bestDiff2 = diff2;  
                  bestC = C;  
                  bestD = D;  
                  found = true;  
              }  
          }  
      }

      if (!found) {  
          result.put("SUB_BEST_Q1", "9999");  
          result.put("SUB_BEST_Q2", "9999");  
      } else {  
          result.put("SUB_BEST_Q1", String.valueOf(bestC));  
          result.put("SUB_BEST_Q2", String.valueOf(bestD));  
      }

    result.put("FUNCTION_CALSUBWEIGHT", "Y");  
      return result;  
  }

  /**  
     * 숫자인지 판별하는 메소드 (소수점 포함)  
     * 빈 값("")이나 문자열이 들어오면 false를 반환  
     */  
  private boolean isInteger(String str) {  
      if (str == null || str.trim().isEmpty()) return false;  
      return str.matches("-?\\d+"); // 음수/양수 정수만 허용  
  }
```

---


1. SUBWEIGHT
- Concrete SW 를 비중 3.2,5.2 으로 대부분 통일함 (기존 비중 2.6, 3.6, 7.25, 7.85, 4가지의 비중이 있음)
- 비중 5.2 (고비중 콘크리트) 추가로 인해 원가절감이 큼
- 비중 2가지로 통일하되 일부 적재높이가 부족하거나 비표준 size의 경우 7.25, 7.85로 대응함
- 비중 3.2 : all 30kg / 비중 5.2는 30kg, 40kg로 구성됨 (40kg는 일부 손잡이 size로 인해 추가됨)

- 조합이 하기와 같이 변경됨 (Concrete만 변경되지만 5.2비중이 추가됨에 따라 FC(7.25)에 대한 사용량이 줄어듬