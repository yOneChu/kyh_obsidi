
---




| 동기 요청사항
```
서브웨이트 전산화해보실거죠?

서브웨이트 로직 크게 4개인데 각각 확인해보시고 어떻게 짜실지, 한번 시뮬해보세요. 

우선 PICK_B181B_LUXEN_G 루젠G 담당으로 드릴게요.

PICK_B181B_NEX  
PICK_B181B_SU  
PICK_B181B_LUXEN_G  
PICK_B181B_NEX_PLANB
```
---

| FUNCTION_CALSUBWEIGHT 사용방법
```

INPUT : 
	SUB_WT_1        1st 자재의 개당 무게
	SUB_H_1          1st 자재의 개당 두께
	SUB_P_1          1st 자재의 개당 가격
	SUB_WT_2     2nd 자재의 개당 무게
	SUB_H_2        2nd 자재의 개당 두께
	SUB_P_2          2nd  자재의 개당 가격
	SUB_NEED_WT   SUBWEIGHT 최소 필요 무게
	SUB_MAX_LOAD_H      SUBWEIGHT 최대 적재가능 높이

OUTPUT:
	SUB_BEST_Q1        1st 자재의 최적 갯수
	SUB_BEST_Q2       2nd 자재의 최적 갯수

1. KEY 값에 `FUNCTION_CALSUBWEIGHT` 에서 사용할 매개변수를 미리 선언.
2. 예시. KEY: SUB_WT_1

```



| SUB-WEIGHT 계산식
![[Pasted image 20251209112101.png]]

```
public VariantMap FUNCTION_CALSUBWEIGHT(Map elvEnt, List<Map> floorMasterList, Map partInfo)  
          throws Exception {

      VariantMap result = new VariantMap();

      // 입력값 읽기  
      String Xs  = StringUtil.NVL(elvEnt.get("SUB_WT_1"), "");  
      String As  = StringUtil.NVL(elvEnt.get("SUB_H_1"), "");  
      String P1s = StringUtil.NVL(elvEnt.get("SUB_P_1"), "");

      String Ys  = StringUtil.NVL(elvEnt.get("SUB_WT_2"), "");  
      String Bs  = StringUtil.NVL(elvEnt.get("SUB_H_2"), "");  
      String P2s = StringUtil.NVL(elvEnt.get("SUB_P_2"), "");

      String AA_s = StringUtil.NVL(elvEnt.get("SUB_NEED_WT"), "");  
      String BB_s = StringUtil.NVL(elvEnt.get("SUB_MAX_LOAD_H"), "");

      // ★ 숫자 체크 (정수만 허용)  
      if (!isInteger(Xs) || !isInteger(As) || !isInteger(P1s)  
              || !isInteger(Ys) || !isInteger(Bs) || !isInteger(P2s)  
              || !isInteger(AA_s) || !isInteger(BB_s)) {

          result.put("SUB_BEST_Q1", "9999");  
          result.put("SUB_BEST_Q2", "9999");  
          return result;  
      }

      // 파싱  
      int X  = Integer.parseInt(Xs);  
      int A  = Integer.parseInt(As);  
      int p1 = Integer.parseInt(P1s);

      int Y  = Integer.parseInt(Ys);  
      int B  = Integer.parseInt(Bs);  
      int p2 = Integer.parseInt(P2s);

      int AA = Integer.parseInt(AA_s);  // 최소 무게  
      int BB = Integer.parseInt(BB_s);  // 최대 두께

      int max = 200;

      boolean found = false;  
      int bestC = -1, bestD = -1;

      int bestCost = Integer.MAX_VALUE;  
      int bestDiff1 = Integer.MAX_VALUE;  // (sum1 - AA)  
      int bestDiff2 = Integer.MAX_VALUE;  // (BB - sum2)

      for (int C = 0; C <= max; C++) {  
          for (int D = 0; D <= max; D++) {

              int sum1 = X * C + Y * D;  
              int sum2 = A * C + B * D;

              if (sum1 < AA) continue;   // 무게 조건  
              if (sum2 > BB) continue;   // 두께 조건 (≤ BB 허용)

              int cost = p1 * C + p2 * D;

              int diff1 = sum1 - AA; // 최소 초과량  
              int diff2 = BB - sum2; // 최대한 근접하도록

              if (cost < bestCost  
                      || (cost == bestCost && (diff1 < bestDiff1  
                      || (diff1 == bestDiff1 && diff2 < bestDiff2)))) {

                  bestCost = cost;  
                  bestDiff1 = diff1;  
                  bestDiff2 = diff2;  
                  bestC = C;  
                  bestD = D;  
                  found = true;  
              }  
          }  
      }

      if (!found) {  
          result.put("SUB_BEST_Q1", "9999");  
          result.put("SUB_BEST_Q2", "9999");  
      } else {  
          result.put("SUB_BEST_Q1", String.valueOf(bestC));  
          result.put("SUB_BEST_Q2", String.valueOf(bestD));  
      }

    result.put("FUNCTION_CALSUBWEIGHT", "Y");  
      return result;  
  }

  /**  
     * 숫자인지 판별하는 메소드 (소수점 포함)  
     * 빈 값("")이나 문자열이 들어오면 false를 반환  
     */  
  private boolean isInteger(String str) {  
      if (str == null || str.trim().isEmpty()) return false;  
      return str.matches("-?\\d+"); // 음수/양수 정수만 허용  
  }
```

